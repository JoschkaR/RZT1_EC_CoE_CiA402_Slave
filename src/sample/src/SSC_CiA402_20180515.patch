diff -u Src/cia402appl.c Src_Cstm/cia402appl.c
--- Src/cia402appl.c	2018-05-15 11:45:06.081048900 +0900
+++ Src_Cstm/cia402appl.c	2018-04-02 13:20:18.121869900 +0900
@@ -55,6 +55,8 @@
 #include "cia402appl.h"
 #undef _CiA402_
 
+#include "renesashw.h"
+
 
 /*--------------------------------------------------------------------------------------
 ------
@@ -100,7 +102,7 @@
         LocalAxes[AxisCnt].bHighLevelPowerApplied = FALSE;
         LocalAxes[AxisCnt].bAxisFunctionEnabled = FALSE;
         LocalAxes[AxisCnt].bConfigurationAllowed = TRUE;
-
+        LocalAxes[AxisCnt].u16AxisNum = AxisCnt+1;
         LocalAxes[AxisCnt].i16State = STATE_NOT_READY_TO_SWITCH_ON;
         LocalAxes[AxisCnt].u16PendingOptionCode = 0x00;
 
@@ -118,40 +120,40 @@
         /***set Object offset to PDO entries***/
 
         /*csv/csp RxPDO*/
-        for (j = 0; j < LocalAxes[AxisCnt].Objects.sRxPDOMap0.u16SubIndex0; j++)
+        for(j =0; j < LocalAxes[AxisCnt].Objects.sRxPDOMap0.u16SubIndex0;j++)
         {
-            LocalAxes[AxisCnt].Objects.sRxPDOMap0.aEntries[j] += AxisCnt* (ObjectOffset << 16);
+            LocalAxes[AxisCnt].Objects.sRxPDOMap0.aEntries[j] += AxisCnt* (ObjectOffset<<16);
         }
 
         /*csp RxPDO*/
-        for (j = 0; j < LocalAxes[AxisCnt].Objects.sRxPDOMap1.u16SubIndex0; j++)
+        for(j =0; j < LocalAxes[AxisCnt].Objects.sRxPDOMap1.u16SubIndex0;j++)
         {
-            LocalAxes[AxisCnt].Objects.sRxPDOMap1.aEntries[j] += AxisCnt* (ObjectOffset << 16);
+            LocalAxes[AxisCnt].Objects.sRxPDOMap1.aEntries[j] += AxisCnt* (ObjectOffset<<16);
         }
 
         /*csv RxPDO*/
-        for (j = 0; j < LocalAxes[AxisCnt].Objects.sRxPDOMap2.u16SubIndex0; j++)
+        for(j =0; j < LocalAxes[AxisCnt].Objects.sRxPDOMap2.u16SubIndex0;j++)
         {
-            LocalAxes[AxisCnt].Objects.sRxPDOMap2.aEntries[j] += AxisCnt* (ObjectOffset << 16);
+            LocalAxes[AxisCnt].Objects.sRxPDOMap2.aEntries[j] += AxisCnt* (ObjectOffset<<16);
         }
 
 
         /*csv/csp TxPDO*/
-        for (j = 0; j < LocalAxes[AxisCnt].Objects.sTxPDOMap0.u16SubIndex0; j++)
+        for(j =0; j < LocalAxes[AxisCnt].Objects.sTxPDOMap0.u16SubIndex0;j++)
         {
-            LocalAxes[AxisCnt].Objects.sTxPDOMap0.aEntries[j] += AxisCnt* (ObjectOffset << 16);
+            LocalAxes[AxisCnt].Objects.sTxPDOMap0.aEntries[j] += AxisCnt* (ObjectOffset<<16);
         }
 
         /*csp TxPDO*/
-        for (j = 0; j < LocalAxes[AxisCnt].Objects.sTxPDOMap1.u16SubIndex0; j++)
+        for(j =0; j < LocalAxes[AxisCnt].Objects.sTxPDOMap1.u16SubIndex0;j++)
         {
-            LocalAxes[AxisCnt].Objects.sTxPDOMap1.aEntries[j] += AxisCnt* (ObjectOffset << 16);
+            LocalAxes[AxisCnt].Objects.sTxPDOMap1.aEntries[j] += AxisCnt* (ObjectOffset<<16);
         }
 
         /*csv TxPDO*/
-        for (j = 0; j < LocalAxes[AxisCnt].Objects.sTxPDOMap2.u16SubIndex0; j++)
+        for(j =0; j < LocalAxes[AxisCnt].Objects.sTxPDOMap2.u16SubIndex0;j++)
         {
-            LocalAxes[AxisCnt].Objects.sTxPDOMap2.aEntries[j] += AxisCnt* (ObjectOffset << 16);
+            LocalAxes[AxisCnt].Objects.sTxPDOMap2.aEntries[j] += AxisCnt* (ObjectOffset<<16);
         }
 
 
@@ -207,6 +209,9 @@
             case 0x605C:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objDisableOperationOptionCode;
                 break;
+            case 0x605D:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objHaltOptionCode;
+                break;
             case 0x605E:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objFaultReactionCode;
                 break;
@@ -216,11 +221,23 @@
             case 0x6061:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objModesOfOperationDisplay;
                 break;
+            case 0x6062:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objPositionDemandValue;
+                break;
+            case 0x6063:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objPositionActualInternalValue;
+                break;
             case 0x6064:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objPositionActualValue;
                 break;
-            case 0x606C:
-                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objVelocityActualValue;
+            case 0x6065:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objFollowingErrorWindow;
+                break;
+            case 0x6067:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objPositionWindow;
+                break;
+            case 0x6072:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objMaxTorque;
                 break;
             case 0x6077:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTorqueActualValue;
@@ -228,28 +245,76 @@
             case 0x607A:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTargetPosition;
                 break;
+            case 0x607C:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objHomeOffset;
+                break;
             case 0x607D:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objSoftwarePositionLimit;
                 break;
             case 0x6085:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objQuickStopDeclaration;
                 break;
-            case 0x60C2:
-                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objInterpolationTimePeriod;
+            case 0x6091:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objGearRatio;
+                break;
+            case 0x6099:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objHomingSpeeds;
+                break;
+            case 0x60B0:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objPositionOffset;
+                break;
+            case 0x60B1:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objVelocityOffset;
+                break;
+            case 0x60B2:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTorqueOffset;
+                break;
+            case 0x60B8:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTouchProbeFunction;
+                break;
+            case 0x60B9:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTouchProbeStatus;
+                break;
+            case 0x60BA:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTouchProbePos1PosValue;
+                break;
+            case 0x60BC:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTouchProbePos2PosValue;
+                break;
+//            case 0x60C2:
+//                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objInterpolationTimePeriod;
+//                break;
+            case 0x60E0:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objPositiveTorqueLimitValue;
+                break;
+            case 0x60E1:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objNegativeTorqueLimitValue;
+                break;
+            case 0x60F4:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objFollowingErrorActualValue;
+                break;
+            case 0x60FD:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objDigitalInputs;
                 break;
             case 0x60FF:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objTargetVelocity;
                 break;
+            case 0x6402:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objMotorType;
+                break;
             case 0x6502:
                 pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objSupportedDriveModes;
                 break;
+            case 0x60FE:
+                pDiCEntry->pVarPtr = &LocalAxes[AxisCnt].Objects.objDigitalOutputs;
+                break;
             default :
                 bObjectFound = FALSE;
             break;
             }//switch(pDiCEntry->Index)
 
             /*increment object index*/
-            if (pDiCEntry->Index >= 0x1400 && pDiCEntry->Index <= 0x1BFF)    //PDO region
+            if(pDiCEntry->Index >= 0x1400 && pDiCEntry->Index <= 0x1BFF)    //PDO region
             {
                 pDiCEntry->Index += AxisCnt* PDOOffset;
             }
@@ -334,19 +399,27 @@
             return;
         }
         /*skip transition 1 and 2*/
-        if (pCiA402Axis->i16State < STATE_READY_TO_SWITCH_ON && nAlStatus == STATE_OP)
-        {
+        if(pCiA402Axis->i16State < STATE_READY_TO_SWITCH_ON && nAlStatus == STATE_OP){
+            if(pCiA402Axis->i16State == STATE_NOT_READY_TO_SWITCH_ON){
+                CiA402_StateTransition1(pCiA402Axis);
+				CiA402_StateTransition2(pCiA402Axis);
+            }
+            if(pCiA402Axis->i16State == STATE_SWITCH_ON_DISABLED){
+                CiA402_StateTransition2(pCiA402Axis);
+            }
+
             pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON;
         }
-
         switch(pCiA402Axis->i16State)
         {
         case STATE_NOT_READY_TO_SWITCH_ON:
             StatusWord |= (STATUSWORD_STATE_NOTREADYTOSWITCHON);
             if(nAlStatus == STATE_OP)
             {
+                if(!CiA402_StateTransition1(pCiA402Axis)){
                 // Automatic transition -> Communication shall be activated
-                pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 1
+                    pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 1
+                }
             }
             else
             {
@@ -369,12 +442,16 @@
             if (((ControlWord6040 & CONTROLWORD_COMMAND_QUICKSTOP_MASK) == CONTROLWORD_COMMAND_QUICKSTOP)
                 || ((ControlWord6040 & CONTROLWORD_COMMAND_DISABLEVOLTAGE_MASK) == CONTROLWORD_COMMAND_DISABLEVOLTAGE))
             {
-                pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 7
-            } 
-            else if (((ControlWord6040 & CONTROLWORD_COMMAND_SWITCHON_MASK) == CONTROLWORD_COMMAND_SWITCHON) ||
+                if(!CiA402_StateTransition7(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 7
+                }
+            } else
+                if (((ControlWord6040 & CONTROLWORD_COMMAND_SWITCHON_MASK) == CONTROLWORD_COMMAND_SWITCHON) ||
                     ((ControlWord6040 & CONTROLWORD_COMMAND_SWITCHON_ENABLEOPERATION_MASK) == CONTROLWORD_COMMAND_SWITCHON_ENABLEOPERATION))
                 {
-                    pCiA402Axis->i16State = STATE_SWITCHED_ON;           // Transition 3
+                    if(!CiA402_StateTransition3(pCiA402Axis)){
+                        pCiA402Axis->i16State = STATE_SWITCHED_ON;           // Transition 3
+                    }
                 }
                 break;
         case STATE_SWITCHED_ON:
@@ -382,19 +459,23 @@
 
             if ((ControlWord6040 & CONTROLWORD_COMMAND_SHUTDOWN_MASK) == CONTROLWORD_COMMAND_SHUTDOWN)
             {
-                pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON; // Transition 6
-
-            } 
-            else if (((ControlWord6040 & CONTROLWORD_COMMAND_QUICKSTOP_MASK) == CONTROLWORD_COMMAND_QUICKSTOP
+                if(!CiA402_StateTransition6(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON; // Transition 6
+                }
+            } else
+                if (((ControlWord6040 & CONTROLWORD_COMMAND_QUICKSTOP_MASK) == CONTROLWORD_COMMAND_QUICKSTOP
                     || (ControlWord6040 & CONTROLWORD_COMMAND_DISABLEVOLTAGE_MASK) == CONTROLWORD_COMMAND_DISABLEVOLTAGE))
                 {
-                    pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 10
-
-                } 
-            else if ((ControlWord6040 & CONTROLWORD_COMMAND_ENABLEOPERATION_MASK) == CONTROLWORD_COMMAND_ENABLEOPERATION)
+                    if(!CiA402_StateTransition10(pCiA402Axis)){
+                        pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 10
+                    }
+                } else
+                    if ((ControlWord6040 & CONTROLWORD_COMMAND_ENABLEOPERATION_MASK) == CONTROLWORD_COMMAND_ENABLEOPERATION)
                     {
-                        pCiA402Axis->i16State = STATE_OPERATION_ENABLED;  // Transition 4
+                        if(!CiA402_StateTransition4(pCiA402Axis)){	
+                            pCiA402Axis->i16State = STATE_OPERATION_ENABLED;  // Transition 4
                         //The Axis function shall be enabled and all internal set-points cleared.
+                        }
                     }
                     break;
         case STATE_OPERATION_ENABLED:
@@ -407,12 +488,17 @@
                     /*disable operation pending*/
                     pCiA402Axis->u16PendingOptionCode = 0x605C; //STATE_TRANSITION (STATE_OPERATION_ENABLED,STATE_SWITCHED_ON);
                     return;
+                }else{
+                    if(!CiA402_StateTransition5(pCiA402Axis)){
+                        pCiA402Axis->i16State = STATE_SWITCHED_ON;        // Transition 5
+                    }
                 }
-                pCiA402Axis->i16State = STATE_SWITCHED_ON;           // Transition 5
             } else
                 if ((ControlWord6040 & CONTROLWORD_COMMAND_QUICKSTOP_MASK) == CONTROLWORD_COMMAND_QUICKSTOP)
                 {
-                    pCiA402Axis->i16State = STATE_QUICK_STOP_ACTIVE;  // Transition 11
+                    if(!CiA402_StateTransition11(pCiA402Axis)){
+                        pCiA402Axis->i16State = STATE_QUICK_STOP_ACTIVE;  // Transition 11
+                    }
                 } else
                     if ((ControlWord6040 & CONTROLWORD_COMMAND_SHUTDOWN_MASK) == CONTROLWORD_COMMAND_SHUTDOWN)
                     {
@@ -421,14 +507,17 @@
                             /*shutdown operation required*/
                             pCiA402Axis->u16PendingOptionCode = 0x605B; //STATE_TRANSITION (STATE_OPERATION_ENABLED,STATE_READY_TO_SWITCH_ON);
                             return;
+                        }else{
+                            if(!CiA402_StateTransition8(pCiA402Axis)){
+                                pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON; // Transition 8
+                            }
                         }
-
-                        pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON; // Transition 8
-
                     } else
                         if ((ControlWord6040 & CONTROLWORD_COMMAND_DISABLEVOLTAGE_MASK) == CONTROLWORD_COMMAND_DISABLEVOLTAGE)
                         {
-                            pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 9
+                            if(!CiA402_StateTransition9(pCiA402Axis)){
+                                pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 9
+                            }
                         }
                         break;
         case STATE_QUICK_STOP_ACTIVE:
@@ -444,10 +533,19 @@
 
             if ((ControlWord6040 & CONTROLWORD_COMMAND_DISABLEVOLTAGE_MASK) == CONTROLWORD_COMMAND_DISABLEVOLTAGE)
             {
-                pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 12
+                if(!CiA402_StateTransition12(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED; // Transition 12
+                }
             }
 
-            /*NOTE: it is not recommend to support transition 16 */
+            /*NOTE: it is recommend to support transition 16 */
+            if ((ControlWord6040 & CONTROLWORD_COMMAND_ENABLEOPERATION_MASK) == CONTROLWORD_COMMAND_ENABLEOPERATION)
+            {
+                if(!CiA402_StateTransition16(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_OPERATION_ENABLED;  // Transition 16
+                    //The Axis function shall be enabled and all internal set-points cleared.
+                }
+            }
             break;
         case STATE_FAULT_REACTION_ACTIVE:
             StatusWord |= (STATUSWORD_STATE_FAULTREACTIONACTIVE);
@@ -456,17 +554,20 @@
                 /*fault reaction pending*/
                 pCiA402Axis->u16PendingOptionCode = 0x605E;
                 return;
+            }else
+                if(!CiA402_StateTransition14(pCiA402Axis)){
+                // Automatic transition
+                pCiA402Axis->i16State = STATE_FAULT;// Transition 14
             }
-
-            // Automatic transition
-            pCiA402Axis->i16State = STATE_FAULT;// Transition 14
             break;
         case STATE_FAULT:
             StatusWord |= (STATUSWORD_STATE_FAULT);
 
             if ((ControlWord6040 & CONTROLWORD_COMMAND_FAULTRESET_MASK) == CONTROLWORD_COMMAND_FAULTRESET)
             {
-                pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED;// Transition 15
+                if(!CiA402_StateTransition15(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED;// Transition 15
+                }
             }
             break;
 
@@ -518,7 +619,7 @@
             break;
         }
 
-        if (pCiA402Axis->bHighLevelPowerApplied == TRUE)
+        if(    pCiA402Axis->bHighLevelPowerApplied == TRUE)
         {
             StatusWord |= STATUSWORD_VOLTAGE_ENABLED;
         }
@@ -534,93 +635,6 @@
 
 /////////////////////////////////////////////////////////////////////////////////////////
 /**
- \param ErrorCode
-
- \brief    CiA402_LocalError
- \brief this function is called if an error was detected
-*////////////////////////////////////////////////////////////////////////////////////////
-void CiA402_LocalError(UINT16 ErrorCode)
-{
-    UINT16 counter = 0;
-    for(counter = 0; counter < MAX_AXES; counter++)
-    {
-        if(LocalAxes[counter].bAxisIsActive)
-        {
-            LocalAxes[counter].i16State = STATE_FAULT_REACTION_ACTIVE;
-            LocalAxes[counter].Objects.objErrorCode = ErrorCode;
-        }
-    }
-}
-
-/////////////////////////////////////////////////////////////////////////////////////////
-/**
- \brief    CiA402_DummyMotionControl
- \brief this functions provides an simple feedback functionality
-*////////////////////////////////////////////////////////////////////////////////////////
-void CiA402_DummyMotionControl(TCiA402Axis *pCiA402Axis)
-{
-    float IncFactor    = (float)0.0010922 * (float) pCiA402Axis->u32CycleTime;
-
-    INT32 i32TargetVelocity = 0;
-    /*Motion Controller shall only be triggered if application is trigger by DC Sync Signals,
-    and a valid mode of operation is set*/
-
-    /*calculate actual position */
-    pCiA402Axis->fCurPosition += ((double)pCiA402Axis->Objects.objVelocityActualValue) * IncFactor;
-    pCiA402Axis->Objects.objPositionActualValue = (INT32)(pCiA402Axis->fCurPosition);
-
-
-    if(pCiA402Axis->bAxisFunctionEnabled &&
-    pCiA402Axis->bLowLevelPowerApplied &&
-    pCiA402Axis->bHighLevelPowerApplied &&
-    !pCiA402Axis->bBrakeApplied)
-    {
-        if((pCiA402Axis->Objects.objSoftwarePositionLimit.i32MaxLimit> pCiA402Axis->Objects.objPositionActualValue
-            || pCiA402Axis->Objects.objPositionActualValue > pCiA402Axis->Objects.objTargetPosition) &&
-            (pCiA402Axis->Objects.objSoftwarePositionLimit.i32MinLimit < pCiA402Axis->Objects.objPositionActualValue
-            || pCiA402Axis->Objects.objPositionActualValue < pCiA402Axis->Objects.objTargetPosition))
-        {
-            pCiA402Axis->Objects.objStatusWord &= ~STATUSWORD_INTERNAL_LIMIT;
-
-            switch(pCiA402Axis->Objects.objModesOfOperationDisplay)
-            {
-            case CYCLIC_SYNC_POSITION_MODE:
-                    if (IncFactor != 0)
-                    {
-                        i32TargetVelocity = (pCiA402Axis->Objects.objTargetPosition - pCiA402Axis->Objects.objPositionActualValue) / ((long)IncFactor);
-                    }
-                    else
-                    {
-                        i32TargetVelocity = 0;
-                    }
-                break;
-            case CYCLIC_SYNC_VELOCITY_MODE:
-                    if (pCiA402Axis->i16State == STATE_OPERATION_ENABLED)
-                    {
-                        i32TargetVelocity = pCiA402Axis->Objects.objTargetVelocity;
-                    }
-                    else
-                    {
-                        i32TargetVelocity = 0;
-                    }
-                break;
-            default:
-                break;
-            }
-        }
-        else
-        {
-            pCiA402Axis->Objects.objStatusWord |= STATUSWORD_INTERNAL_LIMIT;
-        }
-    }
-    pCiA402Axis->Objects.objVelocityActualValue= i32TargetVelocity;
-
-    /*Accept new mode of operation*/
-    pCiA402Axis->Objects.objModesOfOperationDisplay = pCiA402Axis->Objects.objModesOfOperation;
-
-}
-/////////////////////////////////////////////////////////////////////////////////////////
-/**
  \return TRUE if moving on predefined ramp is finished
 
  \brief    CiA402-TransitionAction
@@ -676,7 +690,7 @@
  \brief check if a state transition is pending and pass desired ramp-code to CiA402TransitionAction()
  \brief if this functions returns true the state transition is finished.
 *////////////////////////////////////////////////////////////////////////////////////////
-void CiA402_Application(TCiA402Axis *pCiA402Axis)
+void CiA402_Application(TCiA402Axis *pCiA402Axis, UINT16 i)
 {
     /*clear "Drive follows the command value" flag if the target values from the master overwritten by the local application*/
     if(pCiA402Axis->u16PendingOptionCode != 0 &&
@@ -702,22 +716,22 @@
             /*masked and execute specified quick stop ramp characteristic */
             if(pCiA402Axis->Objects.objQuickStopOptionCode > 4 && pCiA402Axis->Objects.objQuickStopOptionCode <9)
             {
-                    if (pCiA402Axis->Objects.objQuickStopOptionCode == 5)
+                if(pCiA402Axis->Objects.objQuickStopOptionCode == 5)
                     {
-                        ramp = 1;
+                    ramp = 1;
                     }
-                if (pCiA402Axis->Objects.objQuickStopOptionCode == 6)
+                if(pCiA402Axis->Objects.objQuickStopOptionCode == 6)
                 {
                     ramp = 2;
                 }
-                if (pCiA402Axis->Objects.objQuickStopOptionCode == 7)
+                if(pCiA402Axis->Objects.objQuickStopOptionCode == 7)
                 {
                     ramp = 3;
                 }
-                if (pCiA402Axis->Objects.objQuickStopOptionCode == 8)
+                if(pCiA402Axis->Objects.objQuickStopOptionCode == 8)
                 {
                     ramp = 4;
-                }
+            }
             }
 
             if(CiA402_TransitionAction(ramp,pCiA402Axis))
@@ -726,12 +740,13 @@
                 pCiA402Axis->u16PendingOptionCode = 0x0;
                 if(pCiA402Axis->Objects.objQuickStopOptionCode > 0 && pCiA402Axis->Objects.objQuickStopOptionCode < 5)
                 {
-                    pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED;    //continue state transition 12
+                    if(!CiA402_StateTransition12(pCiA402Axis)){
+                        pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED;    //continue state transition 12
+                    }
                 }
-                else if (pCiA402Axis->Objects.objQuickStopOptionCode > 4 && pCiA402Axis->Objects.objQuickStopOptionCode < 9)
-                {
+                else if(pCiA402Axis->Objects.objQuickStopOptionCode > 4 && pCiA402Axis->Objects.objQuickStopOptionCode < 9)
                     pCiA402Axis->Objects.objStatusWord |= STATUSWORD_TARGET_REACHED;
-                }
+                    pCiA402Axis->Objects.objStatusWord &= ~(STATUSWORD_STATE_SWITCHEDONDISABLED);
             }
         }
         break;
@@ -742,7 +757,9 @@
             {
                 /*shutdown ramp is finished complete state transition*/
                 pCiA402Axis->u16PendingOptionCode = 0x0;
-                pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON;    //continue state transition 8
+                if(!CiA402_StateTransition8(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON;    //continue state transition 8
+                }
             }
         }
         break;
@@ -753,7 +770,9 @@
             {
                 /*disable operation ramp is finished complete state transition*/
                 pCiA402Axis->u16PendingOptionCode = 0x0;
-                pCiA402Axis->i16State = STATE_SWITCHED_ON;    //continue state transition 5
+                if(!CiA402_StateTransition5(pCiA402Axis)){
+                    pCiA402Axis->i16State = STATE_SWITCHED_ON;    //continue state transition 5
+                }
             }
         }
         break;
@@ -765,7 +784,10 @@
             {
                 /*fault reaction ramp is finished complete state transition*/
                 pCiA402Axis->u16PendingOptionCode = 0x0;
-                pCiA402Axis->i16State = STATE_FAULT;    //continue state transition 14
+                if(!CiA402_StateTransition14(pCiA402Axis)){
+                    // Automatic transition
+                    pCiA402Axis->i16State = STATE_FAULT;// Transition 14
+                }
             }
         }
         break;
@@ -778,7 +800,11 @@
         && (pCiA402Axis->u32CycleTime != 0)
         && ((pCiA402Axis->Objects.objSupportedDriveModes >> (pCiA402Axis->Objects.objModesOfOperation - 1)) & 0x1)) //Mode of Operation (0x6060) - 1 specifies the Bit within Supported Drive Modes (0x6502)
     {
-        CiA402_DummyMotionControl(pCiA402Axis);
+#if (_DUMMY_ == 1)
+        CiA402_DummyMotionControl(pCiA402Axis, i);
+#else
+        APPL_MOTOR_MotionControl_Main(pCiA402Axis, i);
+#endif
     }
 
 
@@ -826,10 +852,10 @@
         lastSubindex = (UINT8)maxSubindex;
     }
     else
-        if (subindex > maxSubindex)
+    if ( subindex > maxSubindex )
         {
-            /* the maximum subindex is reached */
-            return ABORTIDX_SUBINDEX_NOT_EXISTING;
+        /* the maximum subindex is reached */
+        return ABORTIDX_SUBINDEX_NOT_EXISTING;
         }
     else
     {
@@ -1071,12 +1097,12 @@
         Sync0CycleTime = Sync0CycleTime / 1000; //get cycle time in us
         for(i = 0; i< MAX_AXES;i++)
         {
-                if (LocalAxes[i].bAxisIsActive)
+            if(LocalAxes[i].bAxisIsActive)
                 {
-                    LocalAxes[i].u32CycleTime = Sync0CycleTime;
-                }
+                LocalAxes[i].u32CycleTime = Sync0CycleTime;
         }
     }
+    }
 
     return ALSTATUSCODE_NOERROR;
 }
@@ -1151,7 +1177,7 @@
     TOBJECT OBJMEM *pDiCEntry = NULL;
 
 
-    if (sRxPDOassign.u16SubIndex0 > MAX_AXES)
+    if(sRxPDOassign.u16SubIndex0 > MAX_AXES)
     {
         return ALSTATUSCODE_NOVALIDOUTPUTS;
     }
@@ -1304,10 +1330,16 @@
         case 0:    //copy csp/csv TxPDO entries
             {
                 TCiA402PDO1A00 *pInputs = (TCiA402PDO1A00 *)pTmpData;
-
+                pInputs->ObjErrorCode = SWAPWORD(LocalAxes[AxisIndex].Objects.objErrorCode);
                 pInputs->ObjStatusWord = SWAPWORD(LocalAxes[AxisIndex].Objects.objStatusWord);
                 pInputs->ObjPositionActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objPositionActualValue);
                 pInputs->ObjVelocityActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objVelocityActualValue);
+                pInputs->ObjTorqueActualValue = SWAPWORD(LocalAxes[AxisIndex].Objects.objTorqueActualValue);
+                pInputs->ObjTouchProbeStatus = SWAPWORD(LocalAxes[AxisIndex].Objects.objTouchProbeStatus);
+                pInputs->ObjTouchProbePos1PosValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objTouchProbePos1PosValue);
+                pInputs->ObjTouchProbePos2PosValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objTouchProbePos2PosValue);
+                pInputs->ObjFollowingErrorActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objFollowingErrorActualValue);
+                pInputs->ObjDigitalInputs = SWAPDWORD(LocalAxes[AxisIndex].Objects.objDigitalInputs);
                 pInputs->ObjModesOfOperationDisplay = SWAPWORD((LocalAxes[AxisIndex].Objects.objModesOfOperationDisplay & 0x00FF));
 
                 /*shift pointer PDO mapping object following*/
@@ -1318,29 +1350,42 @@
         case 1://copy csp TxPDO entries
             {
                 TCiA402PDO1A01 *pInputs = (TCiA402PDO1A01 *)pTmpData;
-
+                pInputs->ObjErrorCode = SWAPWORD(LocalAxes[AxisIndex].Objects.objErrorCode);
                 pInputs->ObjStatusWord = SWAPWORD(LocalAxes[AxisIndex].Objects.objStatusWord);
                 pInputs->ObjPositionActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objPositionActualValue);
-
+                pInputs->ObjVelocityActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objVelocityActualValue);
+                pInputs->ObjTorqueActualValue  = SWAPWORD(LocalAxes[AxisIndex].Objects.objTorqueActualValue);
+                pInputs->ObjTouchProbeStatus = SWAPWORD(LocalAxes[AxisIndex].Objects.objTouchProbeStatus);
+                pInputs->ObjTouchProbePos1PosValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objTouchProbePos1PosValue);
+                pInputs->ObjTouchProbePos2PosValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objTouchProbePos2PosValue);
+                pInputs->ObjFollowingErrorActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objFollowingErrorActualValue);
+                pInputs->ObjDigitalInputs = SWAPDWORD(LocalAxes[AxisIndex].Objects.objDigitalInputs);
+      //          pInputs->ObjModesOfOperationDisplay = SWAPWORD((LocalAxes[AxisIndex].Objects.objModesOfOperationDisplay & 0x00FF));
+               
                 /*shift pointer PDO mapping object following*/
-                if (j < (sTxPDOassign.u16SubIndex0 - 1))
-                {
+                if(j < (sTxPDOassign.u16SubIndex0 - 1))
                     pTmpData += SIZEOF(TCiA402PDO1A01);
-                }
             }
             break;
         case 2://copy csv TxPDO entries
             {
                 TCiA402PDO1A02 *pInputs = (TCiA402PDO1A02 *)pTmpData;
-
+                pInputs->ObjErrorCode = SWAPWORD(LocalAxes[AxisIndex].Objects.objErrorCode);
                 pInputs->ObjStatusWord = SWAPWORD(LocalAxes[AxisIndex].Objects.objStatusWord);
                 pInputs->ObjPositionActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objPositionActualValue);
+                pInputs->ObjVelocityActualValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objVelocityActualValue);
+                pInputs->ObjTorqueActualValue = SWAPWORD(LocalAxes[AxisIndex].Objects.objTorqueActualValue);
+                pInputs->ObjTouchProbeStatus = SWAPWORD(LocalAxes[AxisIndex].Objects.objTouchProbeStatus);
+                pInputs->ObjTouchProbePos1PosValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objTouchProbePos1PosValue);
+                pInputs->ObjTouchProbePos2PosValue = SWAPDWORD(LocalAxes[AxisIndex].Objects.objTouchProbePos2PosValue);
+                pInputs->ObjDigitalInputs = SWAPDWORD(LocalAxes[AxisIndex].Objects.objDigitalInputs);
+        //        pInputs->ObjModesOfOperationDisplay = SWAPWORD((LocalAxes[AxisIndex].Objects.objModesOfOperationDisplay & 0x00FF));
             
                 /*shift pointer PDO mapping object following*/
-                if (j < (sTxPDOassign.u16SubIndex0 - 1))
+                if(j < (sTxPDOassign.u16SubIndex0 - 1))
                 {
                     pTmpData += SIZEOF(TCiA402PDO1A02);
-                }
+            }
             }
             break;
         }    //switch TXPDO entry
@@ -1360,6 +1405,7 @@
     UINT8 *pTmpData = (UINT8 *)pData;
     UINT8 AxisIndex;
 
+
     for (j = 0; j < sRxPDOassign.u16SubIndex0; j++)
     {
         /*The Axis index is based on the PDO mapping offset (0x10)*/
@@ -1372,26 +1418,40 @@
             TCiA402PDO1600 *pOutputs = (TCiA402PDO1600 *)pTmpData;
 
             LocalAxes[AxisIndex].Objects.objControlWord = SWAPWORD(pOutputs->ObjControlWord);
+            LocalAxes[AxisIndex].Objects.objModesOfOperation = SWAPWORD((pOutputs->ObjModesOfOperation & 0x00FF));
+            LocalAxes[AxisIndex].Objects.objMaxTorque = SWAPWORD(pOutputs->ObjMaxTorque);
             LocalAxes[AxisIndex].Objects.objTargetPosition = SWAPDWORD(pOutputs->ObjTargetPosition);
+            LocalAxes[AxisIndex].Objects.objPositionOffset = SWAPDWORD(pOutputs->ObjPositionOffset);
+            LocalAxes[AxisIndex].Objects.objVelocityOffset = SWAPDWORD(pOutputs->ObjVelocityOffset);
+            LocalAxes[AxisIndex].Objects.objTorqueOffset = SWAPWORD(pOutputs->ObjTorqueOffset);
+            LocalAxes[AxisIndex].Objects.objTouchProbeFunction = SWAPWORD(pOutputs->ObjTouchProbeFunction);
+            LocalAxes[AxisIndex].Objects.objPositiveTorqueLimitValue = SWAPWORD(pOutputs->ObjPositiveTorqueLimitValue);
+            LocalAxes[AxisIndex].Objects.objNegativeTorqueLimitValue = SWAPWORD(pOutputs->ObjNegativeTorqueLimitValue);
             LocalAxes[AxisIndex].Objects.objTargetVelocity    = SWAPDWORD(pOutputs->ObjTargetVelocity);
-            LocalAxes[AxisIndex].Objects.objModesOfOperation = SWAPWORD((pOutputs->ObjModesOfOperation & 0x00FF));
-
             /*shift pointer PDO mapping object following*/
-            if (j < (sRxPDOassign.u16SubIndex0 - 1))
-            {
+            if(j < (sRxPDOassign.u16SubIndex0 - 1))
                 pTmpData += SIZEOF(TCiA402PDO1600);
             }
-            }
             break;
         case 1:    //csp RxPDO    entries
             {
             TCiA402PDO1601 *pOutputs = (TCiA402PDO1601 *)pTmpData;
 
             LocalAxes[AxisIndex].Objects.objControlWord = SWAPWORD(pOutputs->ObjControlWord);
+            LocalAxes[AxisIndex].Objects.objMaxTorque = SWAPWORD(pOutputs->ObjMaxTorque);
             LocalAxes[AxisIndex].Objects.objTargetPosition = SWAPDWORD(pOutputs->ObjTargetPosition);
-
+            LocalAxes[AxisIndex].Objects.objPositionOffset = SWAPDWORD(pOutputs->ObjPositionOffset);
+            LocalAxes[AxisIndex].Objects.objVelocityOffset = SWAPDWORD(pOutputs->ObjVelocityOffset);
+            LocalAxes[AxisIndex].Objects.objTorqueOffset = SWAPWORD(pOutputs->ObjTorqueOffset);
+            LocalAxes[AxisIndex].Objects.objTouchProbeFunction = SWAPWORD(pOutputs->ObjTouchProbeFunction);
+            LocalAxes[AxisIndex].Objects.objPositiveTorqueLimitValue = SWAPWORD(pOutputs->ObjPositiveTorqueLimitValue);
+            LocalAxes[AxisIndex].Objects.objNegativeTorqueLimitValue = SWAPWORD(pOutputs->ObjNegativeTorqueLimitValue);
+//            LocalAxes[AxisIndex].Objects.objSoftwarePositionLimit.i32MinLimit = SWAPDWORD(pOutputs->ObjSoftwarePositionLimit.i32MinLimit);
+//            LocalAxes[AxisIndex].Objects.objSoftwarePositionLimit.i32MaxLimit = SWAPDWORD(pOutputs->ObjSoftwarePositionLimit.i32MaxLimit);
+            LocalAxes[AxisIndex].Objects.objDigitalOutputs.u32MotorRevolutions = SWAPDWORD(pOutputs->Obj60FE_u32ShaftRevolutions);
+            
             /*shift pointer PDO mapping object following*/
-            if (j < (sRxPDOassign.u16SubIndex0 - 1))
+            if(j < (sRxPDOassign.u16SubIndex0 - 1))
             {
                 pTmpData += SIZEOF(TCiA402PDO1601);
             }
@@ -1402,10 +1462,16 @@
             TCiA402PDO1602 *pOutputs = (TCiA402PDO1602 *)pTmpData;
 
             LocalAxes[AxisIndex].Objects.objControlWord = SWAPWORD(pOutputs->ObjControlWord);
+            LocalAxes[AxisIndex].Objects.objMaxTorque = SWAPWORD(pOutputs->ObjMaxTorque);
+            LocalAxes[AxisIndex].Objects.objVelocityOffset = SWAPDWORD(pOutputs->ObjVelocityOffset);
+            LocalAxes[AxisIndex].Objects.objTorqueOffset = SWAPDWORD(pOutputs->ObjTorqueOffset);
+            LocalAxes[AxisIndex].Objects.objTouchProbeFunction = SWAPWORD(pOutputs->ObjTouchProbeFunction);
+            LocalAxes[AxisIndex].Objects.objPositiveTorqueLimitValue = SWAPWORD(pOutputs->ObjPositiveTorqueLimitValue);
+            LocalAxes[AxisIndex].Objects.objNegativeTorqueLimitValue = SWAPWORD(pOutputs->ObjNegativeTorqueLimitValue);
             LocalAxes[AxisIndex].Objects.objTargetVelocity    = SWAPDWORD(pOutputs->ObjTargetVelocity);
 
             /*shift pointer PDO mapping object following*/
-            if (j < (sRxPDOassign.u16SubIndex0 - 1))
+            if(j < (sRxPDOassign.u16SubIndex0 - 1))
             {
                 pTmpData += SIZEOF(TCiA402PDO1602);
             }
@@ -1425,9 +1491,9 @@
 
     for(i = 0; i < MAX_AXES;i++)
     {
-            if (LocalAxes[i].bAxisIsActive)
+        if(LocalAxes[i].bAxisIsActive)
             {
-                CiA402_Application(&LocalAxes[i]);
+                CiA402_Application(&LocalAxes[i], i);
             }
     }
 }
diff -u Src/cia402appl.h Src_Cstm/cia402appl.h
--- Src/cia402appl.h	2018-05-15 11:45:06.096648900 +0900
+++ Src_Cstm/cia402appl.h	2018-04-02 10:25:21.588508900 +0900
@@ -18,7 +18,6 @@
 <br>Changes to version V5.11:<br>
 V5.12 CIA402 1: change define value STATUSWORD_STATE_SWITCHEDONDISABLED<br>
 V5.12 CIA402 2: update control word mask for transition 3 (Ready to switch on  to Switched on)<br>
-V5.12 CiA402 3: add 16bit padding to process data of csv and csp mode<br>
 <br>Changes to version V5.01:<br>
 V5.11 CiA402 1: "append padding byte to ""csv/csp"" process data (basic process data has odd word length), add pack directive"<br>
 V5.11 COE1: update invalid end entry in the object dictionaries (error with some compilers)<br>
@@ -41,6 +40,12 @@
 ------    Defines and Types
 ------
 -----------------------------------------------------------------------------------------*/
+#define _DUMMY_ 0/**< \brief dummy motion control active*/
+#define COMFORMANCE	1/**< \brief for conformancetest  execute*/
+#define MULTI_AXIS 2/**< \brief for multi axes struct*/
+#define SINGLE_AXIS 3/**< \brief for single axis struct*/
+#define AXIS_STRUCT SINGLE_AXIS
+
 /*---------------------------------------------
 -    ControlWord Commands Mask (IEC61800_184e)
 -----------------------------------------------*/
@@ -350,7 +355,7 @@
 /** \brief 0x1600 (csp/csv RxPDO) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-   UINT32   aEntries[5]; /**< \brief Entry buffer*/
+   UINT32   aEntries[12]; /**< \brief Entry buffer*/
 } OBJ_STRUCT_PACKED_END
 TOBJ1600;
 
@@ -358,9 +363,7 @@
 /** \brief 0x1601 (csp RxPDO) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   UINT32   aEntries[3]; /**< \brief Entry buffer*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+   UINT32   aEntries[10]; /**< \brief Entry buffer*/
 } OBJ_STRUCT_PACKED_END
 TOBJ1601;
 
@@ -368,9 +371,7 @@
 /** \brief 0x1602 (csv RxPDO) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   UINT32   aEntries[3]; /**< \brief Entry buffer*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+   UINT32   aEntries[9]; /**< \brief Entry buffer*/
 } OBJ_STRUCT_PACKED_END
 TOBJ1602;
 
@@ -378,7 +379,7 @@
 /** \brief 0x1A00 (csp/csv TxPDO) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-   UINT32   aEntries[5]; /**< \brief Entry buffer*/
+   UINT32   aEntries[11]; /**< \brief Entry buffer*/
 } OBJ_STRUCT_PACKED_END
 TOBJ1A00;
 
@@ -386,9 +387,7 @@
 /** \brief 0x1A01 (csp TxPDO) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   UINT32   aEntries[3]; /**< \brief Entry buffer*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+   UINT32   aEntries[10]; /**< \brief Entry buffer*/
 } OBJ_STRUCT_PACKED_END
 TOBJ1A01;
 
@@ -396,9 +395,7 @@
 /** \brief 0x1A02 (csv TxPDO) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   UINT32   aEntries[3]; /**< \brief Entry buffer*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+   UINT32   aEntries[9]; /**< \brief Entry buffer*/
 } OBJ_STRUCT_PACKED_END
 TOBJ1A02;
 /** @}*/
@@ -439,14 +436,47 @@
 } OBJ_STRUCT_PACKED_END
 TOBJ607D;
 
+/**
+ * \addtogroup CiA402Objects CiA402 Axis Objects
+ * @{
+ */
+/** \brief 0x6091 (Gear ratio) data structure*/
+typedef struct OBJ_STRUCT_PACKED_START {
+   UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
+   UINT32   u32MotorRevolutions; /**< \brief Motor Revolutions*/
+   UINT32   u32ShaftRevolutions; /**< \Shaft Revolutions*/
+} OBJ_STRUCT_PACKED_END
+TOBJ6091;
 
-/** \brief Object 0x60C2 (Interpolation Time Period) data structure*/
+/**
+ * \addtogroup CiA402Objects CiA402 Axis Objects
+ * @{
+ */
+/** \brief 0x6099 (Homing speeds) data structure*/
 typedef struct OBJ_STRUCT_PACKED_START {
    UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
-   UINT8    u8InterpolationPeriod; /**< \brief Interpolation period*/
-   INT8     i8InterpolationIndex; /**< \brief Interpolation index*/
+   UINT32   u32SpeedDuringSearchForSwitch; /**< \brief Speed during search for switch*/
+   UINT32   u32SpeedDuringSearchForZero; /**< \brief Speed during search for zero*/
+} OBJ_STRUCT_PACKED_END
+TOBJ6099;
+
+
+/** \brief Object 0x60C2 (Interpolation Time Period) data structure*/
+//typedef struct OBJ_STRUCT_PACKED_START {
+//   UINT16   u16SubIndex0; /**< \brief SubIndex 0*/
+//   UINT8    u8InterpolationPeriod; /**< \brief Interpolation period*/
+//   INT8     i8InterpolationIndex; /**< \brief Interpolation index*/
+//} OBJ_STRUCT_PACKED_END
+//TOBJ60C2;
+/** @}*/
+
+/** \brief Object 0x60FE (Digital outputs) data structure*/
+typedef struct OBJ_STRUCT_PACKED_START {
+   UINT16    u16SubIndex0; /**< \brief SubIndex 0*/
+   UINT32    u32MotorRevolutions; /**< \brief MotorRevolutions*/
+   UINT32    u32ShaftRevolutions; /**< \brief ShaftRevolutions*/
 } OBJ_STRUCT_PACKED_END
-TOBJ60C2;
+TOBJ60FE;
 /** @}*/
 
 
@@ -512,73 +542,117 @@
  * @{
  */
 /** \brief Data structure to handle the process data transmitted via 0x1A00 (csp/csv TxPDO)*/
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct STRUCT_PACKED_START
 {
+    UINT16 ObjErrorCode; 		/**< \brief Error code (0x603F)*/	
     UINT16 ObjStatusWord; /**< \brief Status word (0x6041)*/
     INT32 ObjPositionActualValue; /**< \brief Actual position (0x6064)*/
     INT32 ObjVelocityActualValue; /**< \brief Actual velocity (0x606C)*/
+    INT16 ObjTorqueActualValue;/**< \brief Actual torque (0x6077)*/
+    UINT16 ObjTouchProbeStatus;/**< \brief Touch probe status (0x60B9)*/
+    INT32 ObjTouchProbePos1PosValue;/**< \brief Touch probe position 1 positive value (0x60BA)*/
+    INT32 ObjTouchProbePos2PosValue;/**< \brief Touch probe position 2 positive value (0x60BC)*/
+    INT32 ObjFollowingErrorActualValue;/**< \brief Following error actual value (0x60F4)*/
+    UINT32 ObjDigitalInputs;/**< \brief Digital inputs (0x60FD)*/
     INT16 ObjModesOfOperationDisplay; /**< \brief Current mode of operation (0x6061)*/
 }STRUCT_PACKED_END
 TCiA402PDO1A00;
+#pragma pack()	// REL_CiA402_140617
+
 
 
 /** \brief Data structure to handle the process data transmitted via 0x1A01 (csp TxPDO)*/
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct STRUCT_PACKED_START
 {
+    UINT16 ObjErrorCode; 		/**< \brief Error code (0x603F)*/	
     UINT16 ObjStatusWord; /**< \brief Status word (0x6041)*/
     INT32 ObjPositionActualValue; /**< \brief Actual position (0x6064)*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-    UINT16 Padding16Bit; /**< \brief 16bit padding*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+    INT32 ObjVelocityActualValue; /**< \brief Actual velocity (0x606C)*/
+    INT16 ObjTorqueActualValue;/**< \brief Actual torque (0x6077)*/
+    UINT16 ObjTouchProbeStatus;/**< \brief Touch probe status (0x60B9)*/
+    INT32 ObjTouchProbePos1PosValue;/**< \brief Touch probe position 1 positive value (0x60BA)*/
+    INT32 ObjTouchProbePos2PosValue;/**< \brief Touch probe position 2 positive value (0x60BC)*/
+    INT32 ObjFollowingErrorActualValue;/**< \brief Following error actual value (0x60F4)*/
+    UINT32 ObjDigitalInputs;/**< \brief Digital inputs (0x60FD)*/
+//    INT16 ObjModesOfOperationDisplay; /**< \brief Current mode of operation (0x6061)*/
 }STRUCT_PACKED_END
 TCiA402PDO1A01;
-
+#pragma pack()	// REL_CiA402_140617
 
 /** \brief Data structure to handle the process data transmitted via 0x1A02 (csv TxPDO)*/
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct STRUCT_PACKED_START
 {
+    UINT16 ObjErrorCode; 		/**< \brief Error code (0x603F)*/	
     UINT16 ObjStatusWord; /**< \brief Status word (0x6041)*/
     INT32 ObjPositionActualValue; /**< \brief Actual position (0x6064)*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-    UINT16 Padding16Bit; /**< \brief 16bit padding*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+    INT32 ObjVelocityActualValue; /**< \brief Actual velocity (0x606C)*/
+    INT16 ObjTorqueActualValue;/**< \brief Actual torque  (0x6077)*/
+    UINT16 ObjTouchProbeStatus;/**< \brief Touch probe status (0x60B9)*/
+    INT32 ObjTouchProbePos1PosValue;/**< \brief Touch probe position 1 positive value (0x60BA)*/
+    INT32 ObjTouchProbePos2PosValue;/**< \brief Touch probe position 2 positive value (0x60BC)*/
+    UINT32 ObjDigitalInputs;/**< \brief Digital inputs (0x60FD)*/
+//    INT16 ObjModesOfOperationDisplay; /**< \brief Current mode of operation (0x6061)*/
 }STRUCT_PACKED_END
 TCiA402PDO1A02;
-
+#pragma pack()	// REL_CiA402_140617
 
 /** \brief Data structure to handle the process data transmitted via 0x1600 (csp/csv RxPDO)*/
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct STRUCT_PACKED_START
 {
     UINT16 ObjControlWord; /**< \brief Control word (0x6040)*/
+    UINT16 ObjMaxTorque;/**< \brief Max torque (0x6072)*/
     INT32 ObjTargetPosition; /**< \brief Target position (0x607A)*/
+    INT32 ObjPositionOffset;/**< \brief Position offset (0x60B0)*/
+    INT32 ObjVelocityOffset;/**< \brief Velocity offset (0x60B1)*/
+    INT16 ObjTorqueOffset;/**< \brief Torque offset (0x60B2)*/
+    UINT16 ObjTouchProbeFunction;/**< \brief Touch probe function (0x60B8)*/
+    UINT16 ObjPositiveTorqueLimitValue; /**< \brief Positive torque limit value (0x60E0)*/
+    UINT16 ObjNegativeTorqueLimitValue; /**< \brief Negative torque limit value (0x60E1)*/
+    UINT32 Obj60FE_u32ShaftRevolutions; /**< \brief ShaftRevolutions (0x60E0_subindex1)*/
     INT32 ObjTargetVelocity; /**< \brief Target velocity (0x60FF)*/
     INT16 ObjModesOfOperation; /**< \brief Mode of operation (0x6060)*/
 }STRUCT_PACKED_END
 TCiA402PDO1600;
-
+#pragma pack()	// REL_CiA402_140617
 
 /** \brief Data structure to handle the process data transmitted via 0x1601 (csp RxPDO)*/
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct STRUCT_PACKED_START
 {
     UINT16 ObjControlWord; /**< \brief Control word (0x6040)*/
+    UINT16 ObjMaxTorque;/**< \brief Max torque (0x6072)*/
     INT32 ObjTargetPosition; /**< \brief Target position (0x607A)*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-    UINT16 Padding16Bit; /**< \brief 16bit padding*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+    INT32 ObjPositionOffset;/**< \brief Position offset (0x60B0)*/
+    INT32 ObjVelocityOffset;/**< \brief Velocity offset (0x60B1)*/
+    INT16 ObjTorqueOffset;/**< \brief Torque offset (0x60B2)*/
+    UINT16 ObjTouchProbeFunction;/**< \brief Touch probe function (0x60B8)*/
+    UINT16 ObjPositiveTorqueLimitValue; /**< \brief Positive torque limit value (0x60E0)*/
+    UINT16 ObjNegativeTorqueLimitValue; /**< \brief Negative torque limit value (0x60E1)*/
+    UINT32 Obj60FE_u32ShaftRevolutions; /**< \brief ShaftRevolutions (0x60E0_subindex1)*/
 }STRUCT_PACKED_END
 TCiA402PDO1601;
-
+#pragma pack()	// REL_CiA402_140617
 
 /** \brief Data structure to handle the process data transmitted via 0x1602 (csv RxPDO)*/
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct STRUCT_PACKED_START
 {
     UINT16 ObjControlWord; /**< \brief Control word (0x6040)*/
+    UINT16 ObjMaxTorque;/**< \brief Max torque (0x6072)*/
+    INT32 ObjVelocityOffset;/**< \brief Velocity offset (0x60B1)*/
+    INT16 ObjTorqueOffset;/**< \brief Torque offset (0x60B2)*/    
+    UINT16 ObjTouchProbeFunction;/**< \brief Touch probe function (0x60B8)*/
+    UINT16 ObjPositiveTorqueLimitValue; /**< \brief Positive torque limit value (0x60E0)*/
+    UINT16 ObjNegativeTorqueLimitValue; /**< \brief Negative torque limit value (0x60E1)*/
+    UINT32 Obj60FE_u32ShaftRevolutions; /**< \brief ShaftRevolutions (0x60E0_subindex1)*/
     INT32 ObjTargetVelocity; /**< \brief Target velocity (0x60FF)*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-    UINT16 Padding16Bit; /**< \brief 16bit padding*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
 }STRUCT_PACKED_END
 TCiA402PDO1602;
+#pragma pack()	// REL_CiA402_140617
 /** @}*/
 
 
@@ -603,17 +677,39 @@
     INT16 objQuickStopOptionCode; /**< \brief Quick Stop Option Code (0x605A)*/
     INT16 objShutdownOptionCode; /**< \brief Shutdown Option Code (0x605B)*/
     INT16 objDisableOperationOptionCode; /**< \brief Disable Operation Option Code (0x605C)*/
+    INT16 objHaltOptionCode; /**< \brief Halt Option Code (0x605D)*/
     INT16 objFaultReactionCode; /**< \brief Fault Reaction Code (0x605E)*/
     INT16 objModesOfOperation; /**< \brief Modes of Operation (0x6060)*/
     INT16 objModesOfOperationDisplay; /**< \brief Mode of Operation Display (0x6061)*/
+    INT32 objPositionDemandValue; /**< \brief Position Demand Value (0x6062)*/
+    INT32 objPositionActualInternalValue; /**< \brief Position Actual Internal Value (0x6063)*/
     INT32 objPositionActualValue; /**< \brief Position Actual Value (0x6064)*/
+    UINT32 objFollowingErrorWindow;/**< \brief Following Error Window(0x6065)*/
+    UINT32 objPositionWindow;/**< \brief Position Window(0x6067)*/
     INT32 objVelocityActualValue; /**< \brief Actual Velocity Value (0x606C)*/
+    UINT16 objMaxTorque;/**< \brief Max Torque (0x6072)*/
     INT16 objTorqueActualValue; /**< \brief Torque Actual Value (0x6077)*/
+    INT32 objHomeOffset; /**< \brief Home Offset (0x607C)*/
     INT32 objTargetPosition; /**< \brief Target Position (0x607A)*/
     TOBJ607D objSoftwarePositionLimit; /**< \brief Software Position limit (0x607D)*/
     UINT32 objQuickStopDeclaration; /**< \brief Quick Stop Declaration (0x6085)*/
-    TOBJ60C2 objInterpolationTimePeriod; /**< \brief Interpolation Time Period (0x60C2)*/
+    TOBJ6091 objGearRatio;/**< \brief Gear Ratio (0x6091)*/
+    TOBJ6099 objHomingSpeeds; /**< \brief Homing Speeds (0x6099)*/
+    INT32 objPositionOffset;/**< \brief Position Offset (0x60B0)*/
+    INT32 objVelocityOffset;/**< \brief Velocity Offset (0x60B1)*/
+    INT16 objTorqueOffset;/**< \brief Torque Offset (0x60B2)*/
+    UINT16 objTouchProbeFunction;/**< \brief Touch Probe Function (0x60B8)*/
+    UINT16 objTouchProbeStatus; /**< \brief Touch Probe Status (0x60B9)*/
+    INT32 objTouchProbePos1PosValue; /**< \brief Touch Probe Pos 1 Pos Value (0x60BA)*/
+    INT32 objTouchProbePos2PosValue; /**< \brief Touch probe Pos 2 Pos Value (0x60BC)*/
+//    TOBJ60C2 objInterpolationTimePeriod; /**< \brief Interpolation Time Period (0x60C2)*/
+    UINT16 objPositiveTorqueLimitValue; /**< \brief Positive Torque Limit Value (0x60E0)*/
+    UINT16 objNegativeTorqueLimitValue; /**< \brief Negative Torque Limit Value (0x60E1)*/
+    INT32 objFollowingErrorActualValue;/**< \brief Following Error Actual Value (0x60F4)*/
+    UINT32 objDigitalInputs;/**< \brief Digital inputs (0x60FD)*/
+    TOBJ60FE objDigitalOutputs;/**< \brief DigitalOutputs (0x60FE)*/
     INT32 objTargetVelocity; /**< \brief Target Velocity (0x60FF)*/
+    INT16 objMotorType;/**< \brief Motor Type (0x6402)*/
     UINT32 objSupportedDriveModes; /**< \brief Supported Drive Modes (0x6502)*/
 }OBJ_STRUCT_PACKED_END
 CiA402Objects;
@@ -632,7 +728,7 @@
     BOOL        bHighLevelPowerApplied; /**< \brief High Level Power applied*/
     BOOL        bAxisFunctionEnabled; /**< \brief Axis functions enabled*/
     BOOL        bConfigurationAllowed; /**< \brief Configuration allowed*/
-
+    UINT16      u16AxisNum;/**< \brief Axis Number*/
     UINT16      i16State; /**< \brief Axis state*/
     UINT16      u16PendingOptionCode; /**< \brief Pending operation code*/
     double      fCurPosition; /**< \brief Current position within control loop*/
@@ -653,6 +749,7 @@
     #define PROTO extern
 #endif
 
+#define EXTERN extern
 
 /*---------------------------------------------
 -    Entry Descriptions and object names
@@ -703,7 +800,14 @@
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 002*/
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 003*/
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 004*/
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 006*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 007*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 008*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 009*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 010*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 011*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 012*/
 
 
 /**
@@ -720,10 +824,15 @@
 OBJCONST TSDOINFOENTRYDESC	OBJMEM asEntryDesc0x1601[] = {
    {DEFTYPE_UNSIGNED8, 0x8, ACCESS_READ }, /* Subindex 000 */
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 001*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   { DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ }, /* SubIndex 002*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 002*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 004*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 006*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 007*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 008*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 009*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 010*/
 
 
 /**
@@ -740,10 +849,14 @@
 OBJCONST TSDOINFOENTRYDESC	OBJMEM asEntryDesc0x1602[] = {
    {DEFTYPE_UNSIGNED8, 0x8, ACCESS_READ }, /* Subindex 000 */
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 001*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   { DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ }, /* SubIndex 002*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 002*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 004*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 006*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 007*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 008*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 009*/
 
 
 /**
@@ -764,7 +877,13 @@
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 002*/
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 003*/
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 004*/
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 005 */
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 006*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 007*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 008*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 009*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 010*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 011 */
 
    
 /**
@@ -781,10 +900,16 @@
 OBJCONST TSDOINFOENTRYDESC	OBJMEM asEntryDesc0x1A01[] = {
    {DEFTYPE_UNSIGNED8, 0x8, ACCESS_READ }, /* Subindex 000 */
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 001*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   { DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ }, /* SubIndex 002*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 003 */
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 002*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 004*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 006*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 007*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 008*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 009*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 010*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 011 */
 
 
 /**
@@ -802,10 +927,15 @@
 OBJCONST TSDOINFOENTRYDESC	OBJMEM asEntryDesc0x1A02[] = {
    {DEFTYPE_UNSIGNED8, 0x8, ACCESS_READ }, /* Subindex 000 */
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 001*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   { DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ }, /* SubIndex 002*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 002*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 003*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 004*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 005*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 006*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 007*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 008*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}, /* SubIndex 009*/
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}}; /* SubIndex 010 */
 
    
 /**
@@ -860,6 +990,12 @@
 /** \brief Object 0x605C (Disable Operation Option Code) object name*/
 OBJCONST UCHAR OBJMEM aName0x605C[] = "Disable Operation Option Code";
 
+/** \brief Object 0x605D (Halt Option Code) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x605D = {DEFTYPE_INTEGER16, 0x10, ACCESS_READWRITE};
+
+/** \brief Object 0x605D (Halt Option Code) object name*/
+OBJCONST UCHAR OBJMEM aName0x605D[] = "Halt Option Code";
+
 /** \brief Object 0x605E (Fault Reaction Code) entry description*/
 OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x605E = {DEFTYPE_INTEGER16, 0x10, ACCESS_READWRITE};
 
@@ -878,18 +1014,48 @@
 /** \brief Object 0x6061 (Modes of Operation Display) object name*/
 OBJCONST UCHAR OBJMEM aName0x6061[] = "Modes of Operation Display";
 
+/** \brief Object 0x6062 (Position Demand Value) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6062 = {DEFTYPE_INTEGER32, 0x20, ACCESS_READ};
+
+/** \brief Object 0x6062 (Position Demand Value) object name*/
+OBJCONST UCHAR OBJMEM aName0x6062[] = "Position Demand Value";
+
+/** \brief Object 0x6063 (Modes of Operation Display) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6063 = {DEFTYPE_INTEGER32, 0x20, ACCESS_READ};
+
+/** \brief Object 0x6063 (Position Actual Internal Value) object name*/
+OBJCONST UCHAR OBJMEM aName0x6063[] = "Position Actual Internal Value";
+
 /** \brief Object 0x6064 (Position Actual Value) entry description*/
 OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6064 = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
 
 /** \brief Object 0x6064 (Position Actual Value) object name*/
 OBJCONST UCHAR OBJMEM aName0x6064[] = "Position Actual Value";
 
+/** \brief Object 0x6065 (Following error window) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6065 = {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE)};
+
+/** \brief Object 0x6065 (Following error window) object name*/
+OBJCONST UCHAR OBJMEM aName0x6065[] = "Following Error Window";
+
+/** \brief Object 0x6067 (Position Window) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6067 = {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE)};
+
+/** \brief Object 0x6067 (Position Window) object name*/
+OBJCONST UCHAR OBJMEM aName0x6067[] = "Position window";
+
 /** \brief Object 0x606C (Velocity Actual Value) entry description*/
 OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x606C = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
 
 /** \brief Object 0x606C (Velocity Actual Value) object name*/
 OBJCONST UCHAR OBJMEM aName0x606C[] = "Velocity Actual Value";
 
+/**< \brief Object 0x6072 (Max Torque) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6072 = {DEFTYPE_UNSIGNED16, 0x10, (ACCESS_READ|OBJACCESS_RXPDOMAPPING)};
+
+/**< \brief Object 0x6072 (Max Torque) object name*/
+OBJCONST UCHAR OBJMEM aName0x6072[] = "Max Torque";
+
 /** \brief Object 0x6077 (Torque Actual Value) entry description*/
 OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6077 = {DEFTYPE_INTEGER16, 0x10, ACCESS_READ};
 
@@ -902,6 +1068,13 @@
 /** \brief Object 0x607A (Target Position) object name*/
 OBJCONST UCHAR OBJMEM aName0x607A[] = "Target Position";
 
+/** \brief Object 0x607C (Home Offset) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x607C = {DEFTYPE_INTEGER32, 0x20, ACCESS_READWRITE};
+
+/** \brief Object 0x607C (Home Offset) object name*/
+OBJCONST UCHAR OBJMEM aName0x607C[] = "Home Offset";
+
+
 /** 
  * \brief Object 0x607D (Software Position Limit) entry description
  * 
@@ -911,8 +1084,8 @@
  */
 OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x607D[] = {
     {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READ},   
-    {DEFTYPE_INTEGER32, 0x20, ACCESS_READWRITE},
-    {DEFTYPE_INTEGER32, 0x20, ACCESS_READWRITE}}; 
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_BACKUP)},
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_BACKUP)}}; 
 
 
 /** \brief Object 0x607D (Software Position Limit) object and entry names*/
@@ -925,6 +1098,71 @@
 /** \brief Object 0x6085 (Quickstop Declaration) object name*/
 OBJCONST UCHAR OBJMEM aName0x6085[] = "Quickstop Declaration";
 
+/** 
+ * \brief Object 0x6091 (Gear ratio) entry description
+ * 
+ * Subindex 0<br>
+ * Subindex 1 : Motor revolutions<br>
+ * Subindex 2 : Shaft revolutions
+ */
+OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x6091[] = {
+    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READ},   
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_BACKUP)},
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_BACKUP)}}; 
+
+
+/** \brief Object 0x6091 (Gear ratio) object and entry names*/
+OBJCONST UCHAR OBJMEM aName0x6091[] = "Gear ratio\000Motor revolutions\000Shaft revolutions\000\377";
+
+/** 
+ * \brief Object 0x6099 (Homing speeds) entry description
+ * 
+ * Subindex 0<br>
+ * Subindex 1 : Speed during search for switch<br>
+ * Subindex 2 : Speed during search for zero<br>
+ */
+OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x6099[] = {
+    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READ},   
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_BACKUP)},
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_BACKUP)}}; 
+
+/** \brief Object 0x6099 (Homing speeds) object and entry names*/
+OBJCONST UCHAR OBJMEM aName0x6099[] = "Homing speeds\000Speed during search for switch\000Speed during search for zero\000\377";
+
+/**< \brief Object 0x60B0 (Position Offset) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60B0 = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)};
+/**< \brief Object 0x60B0 (Position Offset) object name*/
+OBJCONST UCHAR OBJMEM aName0x60B0[] = "Position Offset";
+
+/**< \brief Object 0x60B1(Velocity Offset) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60B1 = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)};
+/**< \brief Object 0x60B1(Velocity Offset) object name*/
+OBJCONST UCHAR OBJMEM aName0x60B1[] = "Velocity Offset";
+
+/**< \brief Object 0x60B2 (Torque Offset) entry description */
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60B2 = {DEFTYPE_INTEGER16, 0x10, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)};
+/**< \brief Object 0x60B2 (Torque offset) object name */
+OBJCONST UCHAR OBJMEM aName0x60B2[] = "Torque Offset";
+
+/**< \brief Object 0x60B8 (Touch Probe Function) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60B8 = {DEFTYPE_UNSIGNED16, 0x10, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)};
+/**< \brief Object 0x60B8 (Touch Probe Function) object name*/
+OBJCONST UCHAR OBJMEM aName0x60B8[] = "Touch Probe Function";
+
+/**< \brief Object 0x60B9 (Touch Probe Function) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60B9 = {DEFTYPE_UNSIGNED16, 0x10, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
+/**< \brief Object 0x60B9 (Touch Probe Function) object name*/
+OBJCONST UCHAR OBJMEM aName0x60B9[] = "Touch Probe Status";
+
+/**< \brief Object 0x60BA (Touch Probe Function) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60BA = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
+/**< \brief Object 0x60BA (Touch Probe Function) object name*/
+OBJCONST UCHAR OBJMEM aName0x60BA[] = "Touch Probe Pos 1 Pos Value";
+
+/**< \brief Object 0x60BC (Touch Probe Function) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60BC = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
+/**< \brief Object 0x60BC (Touch Probe Function) object name*/
+OBJCONST UCHAR OBJMEM aName0x60BC[] = "Touch Probe Pos 2 Pos Value";
 
 /** 
  * \brief Object 0x60C2 (Interpolation Time Period) entry description
@@ -933,13 +1171,53 @@
  * Subindex 1 : Interpolation time period value<br>
  * Subindex 2 : Interpolation time index
  */
-OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x60C2[] = {
-    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READ},
-    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READWRITE},
-    {DEFTYPE_INTEGER8, 0x08, ACCESS_READWRITE}};
+//OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x60C2[] = {
+//    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READ},
+//    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READWRITE},
+//    {DEFTYPE_INTEGER8, 0x08, ACCESS_READWRITE}};
 
 /** \brief Object 0x60C2 (Interpolation Time Period) object and entry names*/
-OBJCONST UCHAR OBJMEM aName0x60C2[] = "Interpolation Time Period\000Interpolation period \000Interpolation Index\000\377";
+//OBJCONST UCHAR OBJMEM aName0x60C2[] = "Interpolation Time Period\000Interpolation period \000Interpolation Index\000\377";
+
+
+/**< \brief Object 0x60E0 (Positive Torque Limit Value) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60E0 = {DEFTYPE_UNSIGNED16, 0x10, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)};
+/**< \brief Object 0x60E0 (Positive Torque Limit Value) object name*/
+OBJCONST UCHAR OBJMEM aName0x60E0[] = "Positive Torque Limit Value";
+
+
+/**< \brief Object 0x60E1 (Negative Torque Limit Value ) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60E1 = {DEFTYPE_UNSIGNED16, 0x10, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)};
+
+/**< \brief Object 0x60E1 (Negative Torque Limit Value ) object name*/
+OBJCONST UCHAR OBJMEM aName0x60E1[] = "Negative Torque Limit Value";
+
+
+/**< \brief Object 0x60F4 (Following Error Actual Value) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60F4 = {DEFTYPE_INTEGER32, 0x20, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
+/**< \brief Object 0x60F4 (Following Error Actual Value) object name*/
+OBJCONST UCHAR OBJMEM aName0x60F4[] = "Following Error Actual Value";
+/**< \brief Object 0x60FD (Digital Inputs) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x60FD = {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READ|OBJACCESS_TXPDOMAPPING)};
+/**< \brief Object 0x60FD (Digital Inputs) object name*/
+OBJCONST UCHAR OBJMEM aName0x60FD[] = "Digital Inputs";
+
+
+/** 
+ * \brief Object 0x60FE (Digital Outputs) entry description
+ * 
+ * Subindex 0<br>
+ * Subindex 1 : Motor revolutions<br>
+ * Subindex 2 : Shaft revolutions
+ */
+OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x60FE[] = {
+    {DEFTYPE_UNSIGNED8, 0x08, ACCESS_READ},
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_RXPDOMAPPING)},
+    {DEFTYPE_UNSIGNED32, 0x20, (ACCESS_READWRITE|OBJACCESS_SETTINGS)}};
+
+/** \brief Object 0x60FE (Digital Outputs) object name*/
+OBJCONST UCHAR OBJMEM aName0x60FE[] = "Digital Outputs";
+/** @}*/
 
 
 /** \brief Object 0x60FF (Target Velocity) entry description*/
@@ -948,9 +1226,14 @@
 /** \brief Object 0x60FF (Target Velocity) object name*/
 OBJCONST UCHAR OBJMEM aName0x60FF[] = "Target Velocity";
 
+/** \brief Object 0x6402 (Motor type) entry description*/
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6402 = {DEFTYPE_INTEGER16, 0x10, ACCESS_READWRITE};
+
+/** \brief Object 0x6402 (Motor type) object name*/
+OBJCONST UCHAR OBJMEM aName0x6402[] = "Motor Type";
 
 /** \brief Object 0x6502 (Supported Drive Modes) entry description*/
-OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6502 = {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ};
+OBJCONST TSDOINFOENTRYDESC    OBJMEM sEntryDesc0x6502 = {DEFTYPE_INTEGER32, 0x20, ACCESS_READ};
 
 /** \brief Object 0x6502 (Supported Drive Modes) object name*/
 OBJCONST UCHAR OBJMEM aName0x6502[] = "Supported Drive Modes";
@@ -1054,7 +1337,17 @@
  */
 PROTO TOBJ1C12 sRxPDOassign
 #ifdef _CiA402_
-= {1,{0x1602,0x0}}
+
+ #if (AXIS_STRUCT == COMFORMANCE)
+ = {1,{0x1600,0}}
+ #endif
+ #if (AXIS_STRUCT == MULTI_AXIS)
+ = {2,{0x1601,0x1602}}
+ #endif
+ #if (AXIS_STRUCT == SINGLE_AXIS)
+ = {1,{0x1601,0}}
+ #endif
+ 
 #endif
 ;
 
@@ -1068,7 +1361,17 @@
  */
 PROTO TOBJ1C13 sTxPDOassign
 #ifdef _CiA402_
-= {1,{0x1A02,0x0}}
+
+ #if (AXIS_STRUCT == COMFORMANCE)
+ = {1,{0x1A00,0}}
+ #endif
+ #if (AXIS_STRUCT == MULTI_AXIS)
+ = {2,{0x1A01,0x1A02}}
+ #endif
+ #if (AXIS_STRUCT == SINGLE_AXIS)
+ = {1,{0x1A01,0}}
+ #endif
+ 
 #endif
 ;
 /** @}*/
@@ -1114,7 +1417,17 @@
  */
 PROTO TOBJF030 sConfiguredModuleIdentList
 #ifdef _CiA402_
-= {1,{0x319800,0}}
+
+ #if (AXIS_STRUCT == COMFORMANCE)
+ = {1,{0x119800,0}}
+ #endif
+ #if (AXIS_STRUCT == MULTI_AXIS)
+ = {2,{0x219800,0x319800}}
+ #endif
+ #if (AXIS_STRUCT == SINGLE_AXIS)
+ = {1,{0x219800,0}}
+ #endif
+ 
 #endif
 ;
 
@@ -1130,7 +1443,17 @@
  */
 PROTO TOBJF050 sDetectedModuleIdentList
 #ifdef _CiA402_
-= {1,{0x319800,0}}
+
+ #if (AXIS_STRUCT == COMFORMANCE)
+ = {1,{0x119800,0}}
+ #endif
+ #if (AXIS_STRUCT == MULTI_AXIS)
+ = {2,{0x219800,0x319800}}
+ #endif
+ #if (AXIS_STRUCT == SINGLE_AXIS)
+ = {1,{0x219800,0}}
+ #endif
+ 
 #endif
 ;
 /** @}*/
@@ -1147,34 +1470,52 @@
 PROTO CiA402Objects DefCiA402ObjectValues
 #ifdef _CiA402_
 = {
-{5, {0x60400010,0x607A0020,0x60FF0020,0x60600008,0x00000008}},    /* TOBJ1600*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-{3, {0x60400010,0x607A0020,0x00000010 }}, /*TOBJ1601*/
-{3, {0x60400010,0x60FF0020,0x00000010 }}, /*TOBJ1602*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
-{5, {0x60410010,0x60640020,0x606C0020,0x60610008,0x00000008}}, /*TOBJ1A00*/
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-{3, {0x60410010,0x60640020,0x00000010 }}, /*TOBJ1A01*/
-{3, {0x60410010,0x60640020,0x00000010 }},/*TOBJ1A02*/
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+{12, {0x60400010,0x60600008,0x60720010,0x607A0020,0x60B00020,0x60B10020,0x60B20010,0x60B80010,0x60E00010,0x60E10010,0x60FE0020,0x60FF0020}},    /* TOBJ1600*/
+{10, {0x60400010,0x60720010,0x607A0020,0x60B00020,0x60B10020,0x60B20010,0x60B80010,0x60E00010,0x60E10010,0x60FE0020}}, /*TOBJ1601*/
+{9, {0x60400010,0x60720010,0x60B10020,0x60B20010,0x60B80010,0x60E00010,0x60E10010,0x60FE0020,0x60FF0020}}, /*TOBJ1602*/
+{11, {0x603F0010,0x60410010,0x60610008,0x60640020,0x606C0020,0x60770010,0x60B90010,0x60BA0020,0x60BC0020,0x60F40020,0x60FD0020}}, /*TOBJ1A00*/
+{10, {0x603F0010,0x60410010,0x60640020,0x606C0020,0x60770010,0x60B90010,0x60BA0020,0x60BC0020,0x60F40020,0x60FD0020}}, /*TOBJ1A01*/
+{9, {0x603F0010,0x60410010,0x60640020,0x606C0020,0x60770010,0x60B90010,0x60BA0020,0x60BC0020,0x60FD0020}},/*TOBJ1A02*/
 0x0,/*(UINT16) ErrorCode 0x1001*/
 0x0,/*(UINT16) ControlWord 0x6040*/
 0x0,/*(UINT16) StatusWord 0x6041*/
 0x2,/*(INT16) QuickStopOptionCode 0x605A*/
 DISABLE_DRIVE,/*(INT16)ShutdownOptionCode 0x605B*/
 SLOW_DOWN_RAMP, /*(INT16) DisableOperationCode 0x605C*/
+0x0, /*(INT16) HaltOptionCode 0x605D*/
 QUICKSTOP_RAMP,/*(INT16) FaultReactionCode 0x605E*/
-0x0,/*(INT16) ModeOfOperation 0x6060*/
+0x8,/*(INT16) ModeOfOperation 0x6060*/
 0x0,/*(INT16) Mode Of Operation Display 0x6061*/
+0x0,/*(INT32) Position Demand Value 0x6062*/
+0x0,/*(INT32) Position Actual Internal Value 0x6063*/
 0x0,/*(INT32) Position Actual Value 0x6064*/
+0x0,/*(UINT32) Following Error Window 0x6065*/
+0x0,/*(UINT32) Position Window 0x6067*/
 0x0,/*(INT32) Velocity Actual Value 0x606C*/
+0x0,/*(UINT16) Max Torque 0x6072*/
 0x0,/*(INT16) Torque Actual Value 0x6077*/
 0x0,/*(INT32) Target Position 0x607A*/
+0x0,/*(INT32) Home Offset 0x607C*/
 {2,0x88CA6C00,0x77359400},/*TOBJ607D Software Position Limit (minLimit: -2000000000 / maxLimit: 2000000000)*/
 0x0,/*(UINT32) QuickStopDeclaration 0x6085*/
-{2,1,-3},/*TOBJ60C2 Interpolation Time Period*/
+{2,0x0,0x0},/*TOBJ6091 Gear Ratio (Motor revolutions: 0 / Shaft revolutions: 0)*/
+{2,0x0,0x0},/*TOBJ6099 Homing Speeds (Speed during search for switch: 0 / Speed during search for zero: 0)*/
+0x0,/*(INT32) Position Offset 0x60B0*/
+0x0,/*(INT32) Velocity Offset 0x60B1*/
+0x0,/*(INT32) Torque Offset 0x60B2*/
+0x0,/*(UINT16) Touch Probe Function 0x60B8*/
+0x0,/*(UINT16) Touch Probe Status 0x60B9*/
+0x0,/*(INT32) Touch Probe Pos 1 Pos Value 0x60BA*/
+0x0,/*(INT32) Touch Probe Pos 2 Pos Value 0x60BC*/
+//{2,1,-3},/*TOBJ60C2 Interpolation Time Period*/
+0x0,/*(UINT16) Positive Torque Limit Value 0x60E0*/
+0x0,/*(UINT16) Negative Torque Limit Value 0x60E1*/
+0x0,/*(INT32) Following Error Actual Value 0x60F4*/
+0x0,/*(UINT32) Digital Inputs 0x60FD*/
+{2,4,5},/*TOBJ60FE DigitalOutputs*/
 0x0,/*(INT32) Target Velocity    0x60FF*/
-0x0/*(UINT32) Supported Drive Modes 0x6502*/
+0x0,/*(INT16) Motor Type 0x6402*/
+0x180/*(UINT32) Supported Drive Modes 0x6502*/
 }
 #endif
 ;
@@ -1190,6 +1531,7 @@
    {NULL,NULL, 0x1C12, {DEFTYPE_UNSIGNED16, MAX_AXES | (OBJCODE_ARR << 8)}, asPDOAssignEntryDesc, aName0x1C12, &sRxPDOassign, NULL, NULL, 0x0000 },
    /* Object 0x1C13 */
    {NULL,NULL, 0x1C13, {DEFTYPE_UNSIGNED16, MAX_AXES | (OBJCODE_ARR << 8)}, asPDOAssignEntryDesc, aName0x1C13, &sTxPDOassign, NULL, NULL, 0x0000 },
+#if 0
     /* Object 0xF000 */
    {NULL,NULL,   0xF000, {DEFTYPE_RECORD, 2 | (OBJCODE_REC << 8)}, asEntryDesc0xF000, aName0xF000, &sModulardeviceprofile, NULL, NULL, 0x0000 },
     /* Object 0xF010 */
@@ -1198,6 +1540,7 @@
    {NULL,NULL,   0xF030, {DEFTYPE_UNSIGNED32, MAX_AXES | (OBJCODE_ARR << 8)}, asEntryDesc0xF030, aName0xF030, &sConfiguredModuleIdentList, NULL, Write0xF030, 0x0000 },
    /* Object 0xF050 */
    {NULL,NULL, 0xF050, {DEFTYPE_UNSIGNED32, MAX_AXES | (OBJCODE_ARR << 8)}, asEntryDesc0xF050, aName0xF050, &sDetectedModuleIdentList, NULL, NULL, 0x0000 },
+#endif
    {NULL,NULL, 0xFFFF, {0, 0}, NULL, NULL, NULL, NULL, NULL, 0x000}}
 #endif
 ;
@@ -1211,21 +1554,17 @@
 #ifdef _CiA402_
 = {
     /* Object 0x1600 */
-    {NULL,NULL, 0x1600, {DEFTYPE_PDOMAPPING, 5 | (OBJCODE_REC << 8)}, asEntryDesc0x1600, aName0x1600, NULL, NULL, NULL, 0x0000 },
+    {NULL,NULL, 0x1600, {DEFTYPE_PDOMAPPING, 12 | (OBJCODE_REC << 8)}, asEntryDesc0x1600, aName0x1600, NULL, NULL, NULL, 0x0000 },
     /* Object 0x1601 */
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   {NULL,NULL, 0x1601, {DEFTYPE_PDOMAPPING, 3 | (OBJCODE_REC << 8)}, asEntryDesc0x1601, aName0x1601,NULL, NULL, NULL, 0x0000 },
+   {NULL,NULL, 0x1601, {DEFTYPE_PDOMAPPING, 10 | (OBJCODE_REC << 8)}, asEntryDesc0x1601, aName0x1601,NULL, NULL, NULL, 0x0000 },
     /* Object 0x1602 */
-   {NULL,NULL, 0x1602, {DEFTYPE_PDOMAPPING, 3 | (OBJCODE_REC << 8)}, asEntryDesc0x1602, aName0x1602, NULL, NULL, NULL, 0x0000 },
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+   {NULL,NULL, 0x1602, {DEFTYPE_PDOMAPPING, 9 | (OBJCODE_REC << 8)}, asEntryDesc0x1602, aName0x1602, NULL, NULL, NULL, 0x0000 },
    /* Object 0x1A00 */
-   {NULL,NULL, 0x1A00, {DEFTYPE_PDOMAPPING, 5 | (OBJCODE_REC << 8)}, asEntryDesc0x1A00, aName0x1A00, NULL, NULL, NULL, 0x0000 },	
+   {NULL,NULL, 0x1A00, {DEFTYPE_PDOMAPPING, 11 | (OBJCODE_REC << 8)}, asEntryDesc0x1A00, aName0x1A00, NULL, NULL, NULL, 0x0000 },	
    /* Object 0x1A01 */
-/*ECATCHANGE_START(V5.12) CiA402 3*/
-   {NULL,NULL, 0x1A01, {DEFTYPE_PDOMAPPING, 3 | (OBJCODE_REC << 8)}, asEntryDesc0x1A01, aName0x1A01, NULL, NULL, NULL, 0x0000 },	
+   {NULL,NULL, 0x1A01, {DEFTYPE_PDOMAPPING, 11 | (OBJCODE_REC << 8)}, asEntryDesc0x1A01, aName0x1A01, NULL, NULL, NULL, 0x0000 },	
    /* Object 0x1A02 */
-   {NULL,NULL, 0x1A02, {DEFTYPE_PDOMAPPING, 3 | (OBJCODE_REC << 8)}, asEntryDesc0x1A02, aName0x1A02, NULL, NULL, NULL, 0x0000 },	
-/*ECATCHANGE_END(V5.12) CiA402 3*/
+   {NULL,NULL, 0x1A02, {DEFTYPE_PDOMAPPING, 10 | (OBJCODE_REC << 8)}, asEntryDesc0x1A02, aName0x1A02, NULL, NULL, NULL, 0x0000 },	
    /* Object 0x603F */
    {NULL,NULL, 0x603F, {DEFTYPE_UNSIGNED16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x603F, aName0x603F, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6040 */
@@ -1238,30 +1577,74 @@
    {NULL,NULL, 0x605B, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x605B, aName0x605B, NULL, NULL, NULL, 0x0000 },
    /* Object 0x605C */
    {NULL,NULL, 0x605C, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x605C, aName0x605C, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x605D */
+   {NULL,NULL, 0x605D, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x605D, aName0x605D, NULL, NULL, NULL, 0x0000 },
    /* Object 0x605E */
    {NULL,NULL, 0x605E, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x605E, aName0x605E, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6060 */
-    {NULL,NULL, 0x6060, {DEFTYPE_INTEGER8 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6060, aName0x6060, NULL, NULL, NULL, 0x0000 },
+    {NULL,NULL, 0x6060, {DEFTYPE_UNSIGNED8 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6060, aName0x6060, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6061 */
    {NULL,NULL, 0x6061, {DEFTYPE_INTEGER8 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6061, aName0x6061, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6062 */
+   {NULL,NULL, 0x6062, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6062, aName0x6062, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6063 */
+   {NULL,NULL, 0x6063, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6063, aName0x6063, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6064 */
    {NULL,NULL, 0x6064, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6064, aName0x6064, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6065 */
+   {NULL,NULL, 0x6065, {DEFTYPE_UNSIGNED32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6065, aName0x6065, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6067 */
+   {NULL,NULL, 0x6067, {DEFTYPE_UNSIGNED32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6067, aName0x6067, NULL, NULL, NULL, 0x0000 },
    /* Object 0x606C */
    {NULL,NULL, 0x606C, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x606C, aName0x606C, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6072 */
+   {NULL,NULL, 0x6072, {DEFTYPE_UNSIGNED16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6072, aName0x6072, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6077 */
    {NULL,NULL, 0x6077, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6077, aName0x6077, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x607C */
+   {NULL,NULL, 0x607C, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x607C, aName0x607C, NULL, NULL, NULL, 0x0000 },
    /* Object 0x607D */
-   {NULL,NULL, 0x607D, {DEFTYPE_INTEGER32 , 2 | (OBJCODE_ARR << 8)}, asEntryDesc0x607D, aName0x607D, NULL, NULL, NULL, 0x0000 },
+   {NULL,NULL, 0x607D, {DEFTYPE_UNSIGNED32 , 2 | (OBJCODE_REC << 8)}, asEntryDesc0x607D, aName0x607D, NULL, NULL, NULL, 0x0000 },
    /* Object 0x607A */
    {NULL,NULL, 0x607A, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x607A, aName0x607A, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6085 */
    {NULL,NULL, 0x6085, {DEFTYPE_UNSIGNED32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6085, aName0x6085, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6091 */
+   {NULL,NULL, 0x6091, {DEFTYPE_UNSIGNED32 , 2 | (OBJCODE_REC << 8)}, asEntryDesc0x6091, aName0x6091, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6099 */
+   {NULL,NULL, 0x6099, {DEFTYPE_UNSIGNED32 , 2 | (OBJCODE_REC << 8)}, asEntryDesc0x6099, aName0x6099, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60B0 */
+   {NULL,NULL, 0x60B0, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60B0, aName0x60B0, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60B1 */
+   {NULL,NULL, 0x60B1, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60B1, aName0x60B1, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60B2 */
+   {NULL,NULL, 0x60B2, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60B2, aName0x60B2, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60B8 */
+   {NULL,NULL, 0x60B8, {DEFTYPE_UNSIGNED16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60B8, aName0x60B8, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60B9 */
+   {NULL,NULL, 0x60B9, {DEFTYPE_UNSIGNED16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60B9, aName0x60B9, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60BA */
+   {NULL,NULL, 0x60BA, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60BA, aName0x60BA, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60BC */
+   {NULL,NULL, 0x60BC, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60BC, aName0x60BC, NULL, NULL, NULL, 0x0000 },
    /* Object 0x60C2 */
-   {NULL,NULL, 0x60C2, {DEFTYPE_RECORD , 2 | (OBJCODE_REC << 8)}, asEntryDesc0x60C2, aName0x60C2, NULL, NULL, NULL, 0x0000 },
+//   {NULL,NULL, 0x60C2, {DEFTYPE_RECORD , 2 | (OBJCODE_REC << 8)}, asEntryDesc0x60C2, aName0x60C2, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60E0*/
+   {NULL,NULL, 0x60E0, {DEFTYPE_UNSIGNED16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60E0, aName0x60E0, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60E1 */
+   {NULL,NULL, 0x60E1, {DEFTYPE_UNSIGNED16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60E1, aName0x60E1, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60F4 */
+   {NULL,NULL, 0x60F4, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60F4, aName0x60F4, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60FD */
+   {NULL,NULL, 0x60FD, {DEFTYPE_UNSIGNED32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60FD, aName0x60FD, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x60FE */
+   {NULL,NULL, 0x60FE, {DEFTYPE_UNSIGNED32 , 2 | (OBJCODE_REC << 8)}, asEntryDesc0x60FE, aName0x60FE, NULL, NULL, NULL, 0x0000 },
    /* Object 0x60FF */
    {NULL,NULL, 0x60FF, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x60FF, aName0x60FF, NULL, NULL, NULL, 0x0000 },
+   /* Object 0x6402 */
+   {NULL,NULL, 0x6402, {DEFTYPE_INTEGER16 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6402, aName0x6402, NULL, NULL, NULL, 0x0000 },
    /* Object 0x6502 */
-   {NULL,NULL, 0x6502, {DEFTYPE_UNSIGNED32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6502, aName0x6502, NULL, NULL, NULL, 0x0000 },
+   {NULL,NULL, 0x6502, {DEFTYPE_INTEGER32 , 0 | (OBJCODE_VAR << 8)}, &sEntryDesc0x6502, aName0x6502, NULL, NULL, NULL, 0x0000 },
    {NULL,NULL, 0xFFFF, {0, 0}, NULL, NULL, NULL, NULL, NULL, 0x000}}
 #endif
 ;
@@ -1279,9 +1662,29 @@
 PROTO UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize);
 PROTO void APPL_InputMapping(UINT16* pData);
 PROTO void APPL_OutputMapping(UINT16* pData);
+EXTERN UINT16 APPL_MOTOR_MotionControl_Main(TCiA402Axis *pCiA402Axis, UINT16 i);
 
-PROTO void CiA402_LocalError(UINT16 ErrorCode);
+EXTERN void CiA402_LocalError(UINT16 ErrorCode);
 PROTO void CiA402_StateMachine(void);
+PROTO UINT16 CiA402_Init(void);				// REL_CiA402_140617
+PROTO void CiA402_DeallocateAxis(void);		// REL_CiA402_140617
+
+EXTERN UINT16 CiA402_StateTransition1(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition2(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition3(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition4(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition5(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition6(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition7(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition8(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition9(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition10(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition11(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition12(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition14(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition15(TCiA402Axis *pCiA402Axis);
+EXTERN UINT16 CiA402_StateTransition16(TCiA402Axis *pCiA402Axis);
+
 
 #undef PROTO
 /** @}*/
diff -u Src/ecatcoe.h Src_Cstm/ecatcoe.h
--- Src/ecatcoe.h	2018-05-15 11:45:06.127849000 +0900
+++ Src_Cstm/ecatcoe.h	2018-04-02 11:03:22.658118700 +0900
@@ -72,6 +72,7 @@
 /**
  * \brief CoE Mailbox header
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER        MbxHeader; /**< \brief mailbox header*/
@@ -79,7 +80,7 @@
   UINT16            Data[((MAX_MBX_DATA_SIZE)-(COE_HEADER_SIZE)) >> 1]; /**< \brief CoE data*/
 }MBX_STRUCT_PACKED_END
 TCOEMBX;
-
+#pragma pack()	// REL_CiA402_140617
 
 #endif //_ECATCOE_H_
 
diff -u Src/mailbox.h Src_Cstm/mailbox.h
--- Src/mailbox.h	2018-05-15 11:45:06.174649100 +0900
+++ Src_Cstm/mailbox.h	2018-04-02 11:04:31.628215300 +0900
@@ -93,6 +93,7 @@
 /**
  * \brief Mailbox header
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16                          Length; /**< \brief Length*/
@@ -107,6 +108,7 @@
     #define    MBX_SHIFT_COUNTER    4 /**< \brief Protocol counter shift*/
 }MBX_STRUCT_PACKED_END
 TMBXHEADER;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define     MBX_HEADER_SIZE         6 /**< \brief Mailbox header size*/
@@ -117,12 +119,14 @@
 /**
  * \brief Mailbox datagram
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     TMBXHEADER                      MbxHeader; /**< \brief Mailbox header*/
     UINT16                          Data[(MAX_MBX_DATA_SIZE >> 1)]; /**< \brief Mailbox data*/
 }MBX_STRUCT_PACKED_END
 TMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
diff -u Src/sdoserv.h Src_Cstm/sdoserv.h
--- Src/sdoserv.h	2018-05-15 11:45:06.205849100 +0900
+++ Src_Cstm/sdoserv.h	2018-04-02 11:07:43.109483400 +0900
@@ -96,6 +96,7 @@
 /**
  * Structure to handle the basic SDO header
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT8 Sdo[4]; /**< \brief 32Bit SDO header buffer*/
@@ -109,6 +110,7 @@
             #define     SDOHEADER_SUBINDEXSHIFT             0 /**< \brief Shift to get the subindex*/
 }MBX_STRUCT_PACKED_END
 TINITSDOHEADER;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define INITSDO_HEADER_SIZE     4 /**< \brief Size of the SDO header*/
@@ -117,6 +119,7 @@
 /**
  *Complete SDO datagram including mailbox header, CoE header and SDO header
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -124,6 +127,7 @@
   TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
 }MBX_STRUCT_PACKED_END
 TINITSDOMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define     MAX_EXPEDITED_DATA          4 /**< \brief Maximum number of Bytes handled via an expedited transfer*/
@@ -142,6 +146,7 @@
 /**
  * Segmented SDO header including data
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT8        SegHeader; /**< \brief 8Bit header buffer*/
@@ -156,11 +161,13 @@
       UINT8    Data[(MAX_MBX_DATA_SIZE)-(SEGMENT_NORM_HEADER_SIZE)]; /**< \brief Data buffer*/
 }MBX_STRUCT_PACKED_END
 TSDOSEGHEADERDATA;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Expedited download request
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -169,10 +176,12 @@
   UINT16                Data[(MAX_EXPEDITED_DATA) >> 1]; /**< \brief Data buffer*/
 }MBX_STRUCT_PACKED_END
 TINITSDODOWNLOADEXPREQMBX;
+#pragma pack()	// REL_CiA402_140617
 
 /**
  *Normal download request
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -182,11 +191,13 @@
   UINT16                Data[(((MAX_MBX_DATA_SIZE)-(DOWNLOAD_NORM_REQ_SIZE)) >> 1)]; /**< \brief Data buffer*/
 }MBX_STRUCT_PACKED_END
 TINITSDODOWNLOADNORMREQMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Expedited and normal download response:
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -194,11 +205,13 @@
   TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
 }MBX_STRUCT_PACKED_END
 TINITSDODOWNLOADRESMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Segmented download request
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -206,11 +219,13 @@
   TSDOSEGHEADERDATA     SdoHeader; /**< \brief SDO header (data is included in header)*/
 }MBX_STRUCT_PACKED_END
 TDOWNLOADSDOSEGREQMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Segmented download response
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -218,11 +233,13 @@
   UINT8                 SegHeader; /**< \brief SDO header*/
 }MBX_STRUCT_PACKED_END
 TDOWNLOADSDOSEGRESMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Expedited and normal upload request
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -230,11 +247,13 @@
   TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
 }MBX_STRUCT_PACKED_END
 TINITSDOUPLOADREQMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Expedited upload response
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -243,11 +262,13 @@
   UINT16                Data[((MAX_EXPEDITED_DATA) >> 1)]; /**< \brief Data buffer*/
 }MBX_STRUCT_PACKED_END
 TINITSDOUPLOADEXPRESMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Normal upload response
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -257,11 +278,13 @@
   UINT16                Data[(((MAX_MBX_DATA_SIZE)-(UPLOAD_NORM_RES_SIZE)) >> 1)]; /**< \brief Data buffer*/
 }MBX_STRUCT_PACKED_END
 TINITSDOUPLOADNORMRESMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Segmented upload request
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -269,10 +292,12 @@
   UINT8                 SegHeader; /**< \brief SDO header*/
 }MBX_STRUCT_PACKED_END
 TUPLOADSDOSEGREQMBX;
+#pragma pack()	// REL_CiA402_140617
 
 /**
  *Segmented upload response
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -280,11 +305,13 @@
   TSDOSEGHEADERDATA     SdoHeader; /**< \brief SDO header (data is included in header)*/
 }MBX_STRUCT_PACKED_END
 TUPLOADSDOSEGRESMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  *Abort request
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
@@ -293,6 +320,7 @@
   UINT32             AbortCode; /**< \brief SDO abort code*/
 }MBX_STRUCT_PACKED_END
 TABORTSDOTRANSFERREQMBX;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define ABORT_NORM_RES_SIZE    (SIZEOF(TABORTSDOTRANSFERREQMBX) - SIZEOF(TMBXHEADER))/**< \brief Size of the SDO Abort datagram (without the mailbox header)*/
@@ -396,6 +424,7 @@
 /**
  * SDO Info Object list
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16                ListType; /**< \brief List type variable*/
@@ -408,11 +437,13 @@
         #define    INFO_LIST_TYPE_MAX       5 /**< \brief Max list identifier*/
 }MBX_STRUCT_PACKED_END
 TSDOINFOLIST;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  * Object description
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16            DataType; /**< \brief Object data type*/
@@ -431,6 +462,7 @@
 //        char                Name[];                // rest of mailbox data
 }MBX_STRUCT_PACKED_END
 TSDOINFOOBJDESC;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define SDO_INFO_OBJ_DESC_SIZE      SIZEOF(TSDOINFOOBJDESC) /**< \brief Object description size*/
@@ -439,12 +471,14 @@
 /**
  * SDO Info object description service data
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16            Index; /**< \brief Object index*/
     TSDOINFOOBJDESC   Res; /**< \brief Description data*/
 }MBX_STRUCT_PACKED_END
 TSDOINFOOBJ;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define SDO_INFO_OBJ_DESC_RES_SIZE  SIZEOF(TSDOINFOOBJ)/**< \brief Size of the object description service data*/
@@ -453,6 +487,7 @@
 /**
  * SDO Info entry description
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16                DataType; /**< \brief Entry data type*/
@@ -489,11 +524,13 @@
         #define    OBJACCESS_SAFEPARAMETER      0x1000 /**< \brief Safe parameter*/
 }MBX_STRUCT_PACKED_END
 TSDOINFOENTRYDESC;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  * SDO Info entry description service data
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16                Index; /**< \brief Index of the parent object*/
@@ -506,16 +543,19 @@
     TSDOINFOENTRYDESC    Res; /**< \brief Entry description data*/
 }MBX_STRUCT_PACKED_END
 TSDOINFOENTRY;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  * SDO info Error
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT32                ErrorCode; /**< \brief SDO Info error code*/
 }MBX_STRUCT_PACKED_END
 TSDOINFOERROR;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define SDO_INFO_ERROR_SIZE     SIZEOF(TSDOINFOERROR)/**< \brief SDO Info error size*/
@@ -524,6 +564,7 @@
 /**
  *SDO Info header
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
     UINT16 InfoHead; /**< \brief Opcode, Incomplete flag and 8 reserved bits*/
@@ -533,7 +574,7 @@
         #define     INFOHEADER_INCOMPLETE_SHIFT     0 /**< \brief Incomplete shift, the incomplete value "SDOINFOSERVICE_INCOMPLETE" is defined as a UINT8 => no shift required*/
 
     UINT16                FragmentsLeft; /**< \brief Number of fragments which will follow*/
-
+	#pragma pack(1)	// REL_CiA402_140617
     union MBX_STRUCT_PACKED_START
     {
         TSDOINFOLIST    List;/**< \brief List data*/
@@ -543,14 +584,17 @@
         UINT16          Data[1];/**< \brief Unspecified data*/
     }MBX_STRUCT_PACKED_END
     Data;/**< \brief Service data*/
+	#pragma pack()	// REL_CiA402_140617
 
 }MBX_STRUCT_PACKED_END
 TSDOINFOHEADER;
+#pragma pack()	// REL_CiA402_140617
 
 
 /**
  * SDO Info complete datagram
  */
+#pragma pack(1)	// REL_CiA402_140617
 typedef struct MBX_STRUCT_PACKED_START
 {
   TMBXHEADER        MbxHeader; /**< \brief Mailbox header*/
@@ -558,6 +602,7 @@
   TSDOINFOHEADER    SdoHeader; /**< \brief SDO Info header and data*/
 }MBX_STRUCT_PACKED_END
 TSDOINFORMATION;
+#pragma pack()	// REL_CiA402_140617
 
 
 #define     SIZEOF_SDOINFOHEAD                  4 /**< \brief SDO Info header size*/
